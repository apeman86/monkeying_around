{
  "_args": [
    [
      {
        "raw": "typescript_style_guide@git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
        "scope": null,
        "escapedName": "typescript_style_guide",
        "name": "typescript_style_guide",
        "rawSpec": "git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
        "spec": "ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
        "type": "git"
      },
      "D:\\CommonPortal\\ucadmin"
    ]
  ],
  "_from": "git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
  "_id": "typescript_style_guide@0.0.2",
  "_inCache": true,
  "_location": "/typescript_style_guide",
  "_phantomChildren": {},
  "_requested": {
    "raw": "typescript_style_guide@git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
    "scope": null,
    "escapedName": "typescript_style_guide",
    "name": "typescript_style_guide",
    "rawSpec": "git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
    "spec": "ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
    "type": "git"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#fed8a372c93837ff236ece10e56f5813c8b539cd",
  "_shasum": "58e620aac74fba38d46e5640931fe0b6cc01f4ff",
  "_shrinkwrap": null,
  "_spec": "typescript_style_guide@git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git#master",
  "_where": "D:\\CommonPortal\\ucadmin",
  "dependencies": {},
  "description": "TypeScript Style Guide",
  "devDependencies": {},
  "gitHead": "fed8a372c93837ff236ece10e56f5813c8b539cd",
  "license": "UNLICENSED",
  "name": "typescript_style_guide",
  "optionalDependencies": {},
  "private": true,
  "readme": "# TypeScript Style Guide\r\n\r\nThis is the PowerSchool TypeScript style guide\r\n\r\nThe best way to get started using this style guide is to install ```tslint.json``` in your project.\r\n\r\nInstall the required packages.\r\n\r\n```\r\n$ npm install tslint --save-dev\r\n$ npm install gulp-tslint --save-dev\r\n```\r\n\r\nManually add typescript_style_guide to packages.json\r\n\r\n```\r\n// packages.json\r\n{\r\n  \"devDependencies\": {\r\n    \"typescript_style_guide\": \"git+ssh://git@gitswarm.powerschool.com:commonportal/typescript_style_guide.git\"\r\n    ...\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\nYou can use vscode tslint extension or add gulp task to run tslint on build. To add gulp task:\r\n\r\n```\r\nvar gulp = require('gulp');\r\nvar tslint = require('gulp-tslint');\r\n\r\nvar tslintTask = function() {\r\n  return gulp.src(['src/**/*.ts'])\r\n    .pipe(tslint({\r\n      configuration: 'node_modules/typescript_style_guide/tslint.json'\r\n    }))\r\n    .pipe(tslint.report({\r\n      emitError: false,\r\n      summarizeFailureOutput: true\r\n    }));\r\n};\r\n\r\ngulp.task('tslint', tslintTask);\r\nmodule.exports = tslintTask;\r\n```\r\n\r\n## Table of Contents\r\n\r\n  0. [Introduction](#introduction)\r\n  0. [TypeScript 2](#typescript-2)\r\n  0. [Files](#files)\r\n  0. [Indentation](#indentation)\r\n  0. [Line Length](#line-length)\r\n  0. [Quotes](#quotes)\r\n  0. [Comments](#comments)\r\n    0. [Class](#class)\r\n    0. [Inline](#inline)\r\n    0. [Todo and FIXME](#todo-and-fixme)\r\n  0. [Variable Declarations](#variable-declarations)\r\n  0. [Function Declarations](#function-declarations)\r\n    0. [Anonymous Functions](#anonymous-functions)\r\n  0. [Names](#names)\r\n    0. [Variables, Modules, and Functions](#variables-modules-and-functions)\r\n    0. [Use of var, let, and const](#use-of-var-let-and-const)\r\n    0. [Types](#types)\r\n    0. [Classes](#classes)\r\n    0. [Interfaces](#interfaces)\r\n    0. [Constants](#constants)\r\n  0. [Statements](#statements)\r\n    0. [Simple](#simple)\r\n    0. [Compound](#compound)\r\n    0. [Return](#return)\r\n    0. [If](#if)\r\n    0. [For](#for)\r\n    0. [While](#while)\r\n    0. [Do While](#do-while)\r\n    0. [Switch](#switch)\r\n    0. [Try](#try)\r\n    0. [Continue](#continue)\r\n    0. [Throw](#throw)\r\n  0. [Whitespace](#whitespace)\r\n  0. [Object and Array Literals](#object-and-array-literals)\r\n  0. [Assignment Expressions](#assignment-expressions)\r\n  0. [Typings](#assignment-expressions)\r\n    0. [External](#external)\r\n    0. [Internal](#internal)\r\n  0. [Operators](#operators)\r\n    0. [Double and Triple Equal Operators](#double-and-triple-equal-operators)\r\n    0. [Postfix Exclamation Operator](#postfix-exclamation-operator)\r\n  0. [Eval](#eval)\r\n  0. [TSLint](#tslint)\r\n  0. [Rule Overrides](#rule-overrides)\r\n  0. [License](#license)\r\n\r\n## Introduction\r\nWhen developing software as an organization, the value of the software produced is directly affected by the quality of the codebase.\r\nconvention it is easier for new developers to read, preventing a lot of time/frustration spent figuring out the structure and\r\nConsider a project that is developed over many years and handled/seen by many different people. If the project uses a consistent coding\r\ncharacteristics of the code. For that purpose, we need to make sure we adhere to the same coding conventions across all of our products.\r\nThis will not only help new developers, but it will also aid in quickly identifying potential flaws in the code, thereby reducing the\r\nbrittleness of the code.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## TypeScript 2\r\n  - If possible, start using TypeScript 2 with ```strictNullChecks``` enabled. The strictNullChecks option separates null and undefined from\r\n  TypeScript's other types, and makes for more robust and better structured code. New projects should start with this check enabled. \r\n  Existing projects should transition as soon as is practical. To upgrade and enable strictNullChecks, upgrade your TypeScript version and include\r\n  `strictNullChecks:true` in the `compilerOptions` section of your tsconfig.json.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Files\r\n  - All TypeScript files must have a \".ts\" extension.\r\n  - They should be all lower case, and only include letters, numbers, hyphens and periods.\r\n  - Multi words filename should use hypens as the separator (eg. ```user-account.ts```)\r\n  - **All files should end in a new line (\\n). Do not use carriage return (\\n\\r)**. This is necessary for some Unix systems.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Indentation\r\n  - The unit of indentation is two spaces.\r\n  - **Never use tabs**, as this can lead to trouble when opening files in different IDEs/Text editors. Most text editors have a configuration option to change tabs to spaces.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Line Length\r\n  - Lines must not be longer than 140 characters.\r\n  - When a statement runs over 140 characters on a line, it should be broken up, ideally after a comma or operator.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Quotes\r\n  - Use single-quotes `''` for all strings, and use double-quotes `\"\"` for strings within strings.\r\n\r\n  ```typescript\r\n  // bad\r\n  let greeting = \"Hello World!\";\r\n\r\n  // good\r\n  let greeting = 'Hello World!';\r\n\r\n  // bad\r\n  let html = \"<div class='bold'>Hello World</div>\";\r\n\r\n  // bad\r\n  let html = '<div class=\\'bold\\'>Hello World</div>';\r\n\r\n  // good\r\n  let html = '<div class=\"bold\">Hello World</div>';\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Comments\r\n  - Comments are strongly encouraged. It is very useful to be able to read comments and understand the intentions of a given block of code.\r\n  - Comments need to be clear, just like the code they are annotating.\r\n  - Make sure your comments are meaningful.\r\n\r\nThe following example is a case where a comment is completely erroneous, and can actually make the code harder to read.\r\n\r\n  ```typescript\r\n  // Set index to zero.\r\n  let index = 0;\r\n  ```\r\n\r\n  - All public functions must have a comment block `/**...*/` using [JSDoc](http://usejsdoc.org/) style comments.\r\n\r\nJSDocs can be interpreted by IDEs for better intellisense. Below is an example of a JSDoc comment block for a function.\r\n\r\n  ```typescript\r\n  /**\r\n   * Takes in a name and returns a greeting string.\r\n   *\r\n   * @param name The name of the greeted person.\r\n   */\r\n  function getGreeting(name: string): string {\r\n    return 'Hello ' + name + '!';\r\n  }\r\n  ```\r\n\r\n### Class\r\n\r\n  - All classes must have block comments `/**...*/` for all public variables and functions.\r\n  - All public functions should use [JSDoc](http://usejsdoc.org/) style comments.\r\n  - Functions need to have a comment explaining what the function does, and all of the input parameters need to be annotated with `@param`.\r\n  - The class should include a block comment containing the description of the class\r\n  - The constructor should contain a JSDoc comment annotating any input parameters.\r\n\r\n  ```typescript\r\n  /**\r\n   * Contains properties of a Person.\r\n   */\r\n  class Person {\r\n    /**\r\n    * Returns a new Person with the specified name.\r\n    *\r\n    * @param name The name of the new Person.\r\n    */\r\n    static GetPerson(name: string): Person {\r\n      return new Person(name);\r\n    }\r\n\r\n    /**\r\n    * @param name The name of the new Person.\r\n    */\r\n    constructor(public name: string) { }\r\n\r\n    /**\r\n    * Instructs this Person to walk for a certain amount\r\n    * of time.\r\n    *\r\n    * @param millis The number of milliseconds the Person\r\n    * should walk.\r\n    */\r\n    walkFor(millis: number): void {\r\n      console.log(this.name + ' is now walking.');\r\n\r\n      setTimeout(() => {\r\n        console.log(this.name + ' has stopped walking.');\r\n      }, millis);\r\n    }\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Inline\r\n\r\n  - Inline comments are comments inside of complex statements (loops, functions, etc).\r\n  - Use `//` for all inline comments.\r\n  - Keep comments clear and concise.\r\n  - Put an empty line before the comment.\r\n\r\n  ```typescript\r\n  // bad\r\n  function walkFor(name: string, millis: number): void {\r\n    console.log(name + ' is now walking.');\r\n    // Wait for millis milliseconds to stop walking\r\n    setTimeout(() => {\r\n      console.log(name + ' has stopped walking.');\r\n    }, millis);\r\n  }\r\n\r\n  // good\r\n  function walkFor(name: string, millis: number): void {\r\n    console.log(name + ' is now walking.');\r\n\r\n    // Wait for millis milliseconds to stop walking\r\n    setTimeout(() => {\r\n      console.log(name + ' has stopped walking.');\r\n    }, millis);\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Todo and FIXME\r\n\r\n`TODO` and `FIXME` annotations help you quickly find things that need to be fixed/implemented.\r\n\r\n  - Use `// TODO:` to annotate solutions that need to be implemented.\r\n  - Use `// TODO: (yourname)` to add your name.\r\n  - Use `// FIXME:` to annotate problems the need to be fixed.\r\n  - It is best to write code that doesn't need `TODO` and `FIXME` annotations, but sometimes it is unavoidable.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Variable Declarations\r\n\r\n  - All variables must be declared prior to using them. This aids in code readability and helps prevent undeclared variables from being hoisted onto the global scope.\r\n\r\n  ```typescript\r\n  // bad\r\n  console.log(a + b);\r\n\r\n  let a = 2;\r\n  let b = 4;\r\n\r\n  // good\r\n  let a = 2;\r\n  let b = 4;\r\n\r\n  console.log(a + b);\r\n  ```\r\n\r\n  - Implied global variables should never be used.\r\n  - You should never define a variable on the global scope from within a smaller scope.\r\n\r\n  ```typescript\r\n  // bad\r\n  function add(a: number, b: number): number {\r\n    // c is on the global scope!\r\n    c = 6;\r\n\r\n    return a + b + c;\r\n  }\r\n  ```\r\n\r\n  - Use one `let` keyword to define each variable. Reason: you can debug each variable definition.\r\n  - Declare each variable on a newline.\r\n\r\n  ```typescript\r\n  // bad\r\n  let a = 2,\r\n      b = 2,\r\n      c = 4;\r\n\r\n  // good\r\n  let a = 2;\r\n  let b = 2;\r\n  let c = 4;\r\n\r\n  // bad\r\n  // b will be defined on global scope.\r\n  let a = b = 2, c = 4;\r\n  ```\r\n\r\n## Function Declarations\r\n\r\n  - There should be no space between the name of the function and the left parenthesis `(` of its parameter list.\r\n  - There should be one space between the right parenthesis `)` and the left curly `{` brace that begins the statement body.\r\n\r\n  ```typescript\r\n  // bad\r\n  function foo (){\r\n    // ...\r\n  }\r\n\r\n  // good\r\n  function foo() {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n  - The body of the function should be indented 2 spaces.\r\n  - The right curly brace `}` should be on a new line.\r\n  - The right curly brace `}` should be aligned with the line containing the left curly brace `{` that begins the function statement.\r\n\r\n  ```typescript\r\n  // bad\r\n  function foo(): string {\r\n      return 'foo';}\r\n\r\n  // good\r\n  function foo(): string {\r\n    return 'foo';\r\n  }\r\n  ```\r\n\r\n  - For each function parameter\r\n    - There should be no space between the parameter and the colon `:` indicating the type declaration.\r\n    - There should be a space between the colon `:` and the type declaration.\r\n\r\n  ```typescript\r\n  // bad\r\n  function greet(name:string) {\r\n    // ...\r\n  }\r\n\r\n  // good\r\n  function greet(name: string) {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Anonymous Functions\r\n\r\n  - All anonymous functions should be defined as fat-arrow/lambda `() => { }` functions unless it is absolutely necessary to preserve the context in the function body.\r\n  - All fat-arrow/lambda functions should have parenthesis `()` around the function parameters.\r\n\r\n  ```typescript\r\n  // bad\r\n  clickAlert() {\r\n    let element = document.querySelector('div');\r\n\r\n    this.foo = 'foo';\r\n\r\n    element.addEventListener('click', function(ev: Event) {\r\n      // this.foo does not exist!\r\n      alert(this.foo);\r\n    });\r\n  }\r\n\r\n  // good\r\n  clickAlert() {\r\n    let element = document.querySelector('div');\r\n\r\n    this.foo = 'foo';\r\n\r\n    element.addEventListener('click', (ev: Event) => {\r\n      // TypeScript allows this.foo to exist!\r\n      alert(this.foo);\r\n    });\r\n  }\r\n  ```\r\n\r\n  - There should be a space between the right parenthesis `)` and the `=>`\r\n  - There should be a space between the `=>` and the left curly brace `{` that begins the statement body.\r\n\r\n  ```typescript\r\n  // bad\r\n  element.addEventListener('click', (ev: Event)=>{alert('foo');});\r\n\r\n  // good\r\n  element.addEventListener('click', (ev: Event) => {\r\n    alert('foo');\r\n  });\r\n  ```\r\n\r\n  - The statement body should be indented 2 spaces.\r\n  - The right curly brace `}` should be on a new line.\r\n  - The right curly brace `}` should be aligned with the line containing the  left curly brace `{` that begins the function statement.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Names\r\n\r\n  - All variable and function names should be formed with alphanumeric `A-Z, a-z, 0-9` and underscore `_` charcters.\r\n\r\n### Variables, Modules, and Functions\r\n\r\n  - Variable, module, and function names should use lowerCamelCase.\r\n\r\n### Use of var, let, and const\r\n\r\n  - Use `const` where appropriate, for values that should never change\r\n  - Use `let` everywhere else\r\n  - Avoid using `var`\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Types\r\n\r\n  - Always favor type inference over explicit type declaration except for function return types\r\n  - Always define the return type of functions.\r\n  - Types should be used whenever necessary (no implicit `any`).\r\n  - Use the `any` type sparingly, it is always better to define an interface.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Classes\r\n\r\n  - Classes/Constructors should use UpperCamelCase (PascalCase).\r\n  - `Private` and `private static` members in classes should be denoted with the `private` keyword.\r\n  - `Protected` members in classes do not use the `private` keyword.\r\n  - Default to using `protected` for all instance members\r\n  - Use `private` instance members sparingly\r\n  - Use `public` instance members only when they are used by other parts of the application.\r\n\r\n  ```typescript\r\n  class Person {\r\n    protected fullName: string;\r\n\r\n    constructor(public firstName: string, public lastName: string) {\r\n      this.fullName = firstName + ' ' + lastName;\r\n    }\r\n\r\n    toString() {\r\n      return this.fullName;\r\n    }\r\n\r\n    protected walkFor(millis: number) {\r\n      console.log(this.fullName + ' is now walking.');\r\n\r\n      // Wait for millis milliseconds to stop walking\r\n      setTimeout(() => {\r\n        console.log(this.fullName + ' has stopped walking.');\r\n      }, millis);\r\n    }\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Interfaces\r\n\r\n  - Interfaces should use UpperCamelCase.\r\n  - Only `public` members should be in an interface, leave out `protected` and `private` members.\r\n\r\n  ```typescript\r\n  interface Person {\r\n    firstName: string;\r\n    lastName: string;\r\n    toString(): string;\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Constants\r\n\r\n  - All constants should use UPPER_SNAKE_CASE.\r\n  - All constants should be defined with the `const` keyword.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Statements\r\n\r\n### Simple\r\n\r\n  - Each line should contain at most one statement.\r\n  - A semicolon should be placed at the end of every simple statement.\r\n\r\n  ```typescript\r\n  // bad\r\n  let greeting = 'Hello World'\r\n\r\n  alert(greeting)\r\n\r\n  // good\r\n  let greeting = 'Hello World';\r\n\r\n  alert(greeting);\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Compound\r\n\r\nCompound statements are statements containing lists of statements enclosed in curly braces `{}`.\r\n\r\n  - The enclosed statements should start on a newline.\r\n  - The enclosed statements should be indented 2 spaces.\r\n\r\n  ```typescript\r\n  // bad\r\n  if (condition === true) { alert('Passed!'); }\r\n\r\n  // good\r\n  if (condition === true) {\r\n    alert('Passed!');\r\n  }\r\n  ```\r\n  - The left curly brace `{` should be at the end of the line that begins the compound statement.\r\n  - The right curly brace `}` should begin a line and be indented to align with the line containing the left curly brace `{`.\r\n\r\n  ```typescript\r\n  // bad\r\n  if (condition === true)\r\n  {\r\n    alert('Passed!');\r\n  }\r\n\r\n  // good\r\n  if (condition === true) {\r\n    alert('Passed!');\r\n  }\r\n  ```\r\n\r\n  - **Braces `{}` must be used around all compound statements** even if they are only single-line statements.\r\n\r\n  ```typescript\r\n  // bad\r\n  if (condition === true) alert('Passed!');\r\n\r\n  // bad\r\n  if (condition === true)\r\n    alert('Passed!');\r\n\r\n  // good\r\n  if (condition === true) {\r\n    alert('Passed!');\r\n  }\r\n  ```\r\n\r\nIf you do not add braces `{}` around compound statements, it makes it very easy to accidentally introduce bugs.\r\n\r\n  ```typescript\r\n  if (condition === true)\r\n    alert('Passed!');\r\n    return condition;\r\n  ```\r\n\r\nIt appears the intention of the above code is to return if `condition === true`, but without braces `{}` the return statement will be executed regardless of the condition.\r\n\r\n  - Compount statements do not need to end in a semicolon `;` with the exception of a `do { } while();` statement.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Return\r\n\r\n  - If a `return` statement has a value you should not use parenthesis `()` around the value.\r\n  - The return value expression must start on the same line as the `return` keyword.\r\n\r\n  ```typescript\r\n  // bad\r\n  return\r\n      'Hello World!';\r\n\r\n  // bad\r\n  return ('Hello World!');\r\n\r\n  // good\r\n  return 'Hello World!';\r\n  ```\r\n\r\n  - It is recommended to take a return-first approach whenever possible.\r\n\r\n  ```typescript\r\n  // bad\r\n  function getHighestNumber(a: number, b: number): number {\r\n    let out = b;\r\n\r\n    if (a >= b) {\r\n      out = a;\r\n    }\r\n\r\n    return out;\r\n  }\r\n\r\n  // good\r\n  function getHighestNumber(a: number, b: number): number {\r\n    if (a >= b) {\r\n      return a;\r\n    }\r\n\r\n    return b;\r\n  }\r\n  ```\r\n\r\n  - Always **explicitly define a return type**. This can help TypeScript validate that you are always returning something that matches the correct type.\r\n\r\n  ```typescript\r\n  // bad\r\n  function getPerson(name: string) {\r\n    return new Person(name);\r\n  }\r\n\r\n  // good\r\n  function getPerson(name: string): Person {\r\n    return new Person(name);\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### If\r\n\r\n  - Alway be explicit in your `if` statement conditions.\r\n\r\n  ```typescript\r\n  // bad\r\n  function isString(str: any) {\r\n    return !!str;\r\n  }\r\n\r\n  // good\r\n  function isString(str: any) {\r\n    return typeof str === 'string';\r\n  }\r\n  ```\r\n\r\nSometimes simply checking falsy/truthy values is fine, but the general approach is to be explicit with what you are looking for. This can prevent a lot of unncessary bugs.\r\n\r\nIf statements should take the following form:\r\n\r\n  ```typescript\r\n  if (/* condition */) {\r\n    // ...\r\n  }\r\n\r\n  if (/* condition */) {\r\n    // ...\r\n  } else {\r\n    // ...\r\n  }\r\n\r\n  if (/* condition */) {\r\n    // ...\r\n  } else if (/* condition */) {\r\n    // ...\r\n  } else {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### For\r\n\r\nFor statements should have the following form:\r\n\r\n  ```typescript\r\n  for (/* initialization */; /* condition */; /* update */) {\r\n    // ...\r\n  }\r\n\r\n  ```\r\n\r\nUse Object.prototype.keys in lieu of a `for...in` statement.\r\n\r\nReason: `for...in` can be mistakenly used on an array. \r\n \r\n  ```typescript\r\n  let o = { foo: 'bar' };\r\n  Object.keys(o).forEach((key) => {\r\n    console.log([key, o[key]]);\r\n  });\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### While\r\n\r\nWhile statements should have the following form:\r\n\r\n  ```typescript\r\n  while (/* condition */) {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Do While\r\n\r\n  - Do while statements should be avoided unless absolutely necessary to maintain consistency.\r\n  - Do while statements must end with a semicolon `;`\r\n\r\nDo while statements should have to following form:\r\n\r\n  ```typescript\r\n  do {\r\n    // ...\r\n  } while (/* condition */);\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Switch\r\n\r\nSwitch statements should have the following form:\r\n\r\n  ```typescript\r\n  switch (/* expression */) {\r\n    case /* expression */:\r\n      // ...\r\n      /* termination */\r\n    default:\r\n      // ...\r\n  }\r\n  ```\r\n\r\n  - Each switch group except default should end with `break`, `return`, or `throw`.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Try\r\n\r\n  - Try statements should be avoided whenever possible. They are not a good way of providing flow control.\r\n\r\nTry statements should have the following form:\r\n\r\n  ```typescript\r\n  try {\r\n    // ...\r\n  } catch (error: Error) {\r\n    // ...\r\n  }\r\n\r\n  try {\r\n    // ...\r\n  } catch (error: Error) {\r\n    // ...\r\n  } finally {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Continue\r\n\r\n  - It is recommended to take a continue-first approach in all loops.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Throw\r\n\r\n  - Avoid the use of the throw statement unless absolutely necessary.\r\n  - Flow control through try/catch exception handling is not recommended.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Whitespace\r\n\r\nBlank lines improve code readability by allowing the developer to logically group code blocks. Blank spaces should be used in the following circumstances.\r\n\r\n  - A keyword followed by left parenthesis `(` should be separated by 1 space.\r\n\r\n  ```typescript\r\n  // bad\r\n  if(condition) {\r\n    // ...\r\n  }\r\n\r\n  // good\r\n  if (condition) {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n  - All operators except for period `.`, left parenthesis `(`, and left bracket `[` should be separated from their operands by a space.\r\n\r\n  ```typescript\r\n  // bad\r\n  let sum = a+b;\r\n\r\n  // good\r\n  let sum = a + b;\r\n\r\n  // bad\r\n  let name = person . name;\r\n\r\n  // good\r\n  let name = person.name;\r\n\r\n  // bad\r\n  let item = items [4];\r\n\r\n  // good\r\n  let item = items[4];\r\n  ```\r\n\r\n  - No space should separate a unary/incremental operator `!x, -x, +x, ~x, ++x, --x` and its operand.\r\n\r\n  ```typescript\r\n  // bad\r\n  let neg = - a;\r\n\r\n  // good\r\n  let neg = -a;\r\n  ```\r\n\r\n  - Each semicolon `;` in the control part of a `for` statement should be followed with a space.\r\n\r\n  ```typescript\r\n  // bad\r\n  for(let i = 0;i < 10;++i) {\r\n    // ...\r\n  }\r\n\r\n  // good\r\n  for (let i = 0; i < 10; ++i) {\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Object and Array Literals\r\n\r\n  - Use curly braces `{}` instead of `new Object()`.\r\n  - Use brackets `[]` instead of `new Array()`.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Assignment Expressions\r\n\r\n  - Assignment expressions inside of the condition block of `if`, `while`, and `do while` statements should be avoided.\r\n\r\n  ```typescript\r\n  // bad\r\n  while (node = node.next) {\r\n    // ...\r\n  }\r\n\r\n  // good\r\n  while (typeof node === 'object') {\r\n    node = node.next;\r\n\r\n    // ...\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Operators\r\n\r\n### Double and Triple Equal Operators\r\n\r\n  - It is better to use `===` and `!==` operators whenever possible.\r\n  - `==` and `!=` operators do type coercion, which can lead to headaches when debugging code.\r\n  - The one exception is `== null` and `!= null`, which is the recommended way of checking for null or undefined.\r\n\r\n**[top](#table-of-contents)**\r\n\r\n### Postfix Exclamation Operator\r\n\r\n  - TypeScript 2.0 provides a postfix `!` operator, which declares to the compiler that its operand is never null or undefined.\r\nThe operator may be necessary in rare cases, but a good rule of thumb is to avoid it where possible. Use of postfix `!` is often\r\na bad smell, indicating that the code is not being careful about types. You may be tempted to use it after an error appears when turning\r\non strictNullChecks, but we find that generally the code benefits from recasting it so the operator is unnecessary. An example of a case\r\nwhere it is fine to use is on the key for the lodash _.forOwn construct. The key is always a string if an object is being iterated over, \r\nbut the type is (string|undefined).\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Typings\r\n\r\n### External\r\n\r\n  - Typings are sometimes packaged with node modules, in this case you don't need to do anything\r\n  - Use [typings](https://github.com/typings/typings) for all external library declarations not included in `node_modules`\r\n  - Actively add/update/contribute typings when they are missing\r\n\r\n### Internal\r\n\r\n  - Create declaration files `.d.ts` for your interfaces instead of putting them in your `.ts` files\r\n  - Let the TypeScript compiler infer as much as possible\r\n  - Avoid defining types when it is unnecessary\r\n\r\n  ```typescript\r\n  // bad\r\n  let a: number = 2;\r\n\r\n  // good\r\n  let a = 2;\r\n  ```\r\n\r\n  - Always define the return type of functions, this helps to make sure that functions always return the correct type\r\n\r\n  ```typescript\r\n  // bad\r\n  function sum(a: number, b: number) {\r\n    return a + b;\r\n  }\r\n\r\n  // good\r\n  function sum(a: number, b: number): number {\r\n    return a + b;\r\n  }\r\n  ```\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## Eval\r\n\r\n  - **Never use eval**\r\n  - **Never use the Function constructor**\r\n  - **Never pass strings to `setTimeout` or `setInterval`**\r\n\r\n**[top](#table-of-contents)**\r\n\r\n## TSLint\r\n\r\n  - Always use a Linter\r\n\r\nLinting your code is very helpful for preventing minor issues that can escape the eye during development. We use TSLint (written by Palantir) for our linter.\r\n\r\n  - TSLint: https://github.com/palantir/tslint\r\n  - Our [tslint.json](https://github.com/Platypi/style_typescript/blob/master/tslint.json)\r\n\r\n## Rule Overrides\r\nRules can be ignored within files by adding flags to the code to get rid of errors on properly written code.\r\n  - Override syntax https://palantir.github.io/tslint/usage/rule-flags/\r\n  - List of rules by name: https://palantir.github.io/tslint/rules/\r\n\r\n## License\r\n(The MIT License)\r\n\r\nCopyright (c) 2014 Platypi, LLC\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nI like to eat candy. I ate too much yesterday. The good news is, it's all on sale today.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "https://gitswarm.powerschool.com/commonportal/typescript_style_guide"
  },
  "version": "0.0.2"
}
